use crate::signer::keys::{DynSigner, InnerSign, PaymentSign, SpendableKeysInterface};
use anyhow::Result;
use bitcoin::secp256k1::recovery::RecoverableSignature;
use bitcoin::secp256k1::{All, PublicKey, Secp256k1, SecretKey};
use bitcoin::{Script, Transaction, TxOut};
use lightning::chain::keysinterface::{
	DelayedPaymentOutputDescriptor, KeysInterface, SpendableOutputDescriptor,
	StaticPaymentOutputDescriptor,
};
use lightning::ln::msgs::DecodeError;
use lightning_signer::node::NodeConfig;
use lightning_signer::signer::multi_signer::MultiSigner;
use lightning_signer::signer::my_keys_manager::KeyDerivationStyle;
use lightning_signer::util::loopback::{LoopbackChannelSigner, LoopbackSignerKeysInterface};
use std::any::Any;
use std::sync::Arc;

struct Adapter {
	inner: LoopbackSignerKeysInterface,
}

impl PaymentSign for LoopbackChannelSigner {
	#[allow(unused)]
	fn sign_counterparty_payment_input_t(
		&self, spend_tx: &Transaction, input_idx: usize,
		descriptor: &StaticPaymentOutputDescriptor, secp_ctx: &Secp256k1<All>,
	) -> Result<Vec<Vec<u8>>, ()> {
		todo!()
	}

	#[allow(unused)]
	fn sign_dynamic_p2wsh_input_t(
		&self, spend_tx: &Transaction, input_idx: usize,
		descriptor: &DelayedPaymentOutputDescriptor, secp_ctx: &Secp256k1<All>,
	) -> Result<Vec<Vec<u8>>, ()> {
		todo!()
	}
}

impl InnerSign for LoopbackChannelSigner {
	fn box_clone(&self) -> Box<dyn InnerSign> {
		Box::new(self.clone())
	}

	fn as_any(&self) -> &dyn Any {
		self
	}

	fn vwrite(&self, _writer: &mut Vec<u8>) -> Result<(), std::io::Error> {
		//self.write(writer)
		// Do nothing for now, we'll have our own persistence strategy
		Ok(())
	}
}

impl KeysInterface for Adapter {
	type Signer = DynSigner;

	fn get_node_secret(&self) -> SecretKey {
		self.inner.get_node_secret()
	}

	fn get_destination_script(&self) -> Script {
		self.inner.get_destination_script()
	}

	fn get_shutdown_pubkey(&self) -> PublicKey {
		self.inner.get_shutdown_pubkey()
	}

	fn get_channel_signer(&self, inbound: bool, channel_value_satoshis: u64) -> Self::Signer {
		let inner = self.inner.get_channel_signer(inbound, channel_value_satoshis);
		DynSigner { inner: Box::new(inner) }
	}

	fn get_secure_random_bytes(&self) -> [u8; 32] {
		self.inner.get_secure_random_bytes()
	}

	fn read_chan_signer(&self, _reader: &[u8]) -> Result<Self::Signer, DecodeError> {
		unimplemented!()
	}

	fn sign_invoice(&self, _invoice_preimage: Vec<u8>) -> Result<RecoverableSignature, ()> {
		unimplemented!()
	}
}

impl SpendableKeysInterface for Adapter {
	/// Creates a Transaction which spends the given descriptors to the given outputs, plus an
	/// output to the given change destination (if sufficient change value remains). The
	/// transaction will have a feerate, at least, of the given value.
	///
	/// Returns `Err(())` if the output value is greater than the input value minus required fee or
	/// if a descriptor was duplicated.
	///
	/// We do not enforce that outputs meet the dust limit or that any output scripts are standard.
	///
	/// May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
	/// this KeysManager or one of the `DynSigner` created by this KeysManager.
	fn spend_spendable_outputs(
		&self, descriptors: &[&SpendableOutputDescriptor], outputs: Vec<TxOut>,
		change_destination_script: Script, feerate_sat_per_1000_weight: u32,
		secp_ctx: &Secp256k1<All>,
	) -> Result<Transaction> {
		self.inner
			.spend_spendable_outputs(
				descriptors,
				outputs,
				change_destination_script,
				feerate_sat_per_1000_weight,
				secp_ctx,
			)
			.map_err(|()| anyhow::anyhow!("failed in spend_spendable_outputs"))
	}
}

pub(crate) fn make_signer() -> Box<dyn SpendableKeysInterface<Signer = DynSigner>> {
	// FIXME used Node directly
	let signer = MultiSigner::new();
	let node_config = NodeConfig { key_derivation_style: KeyDerivationStyle::Native };
	let node_id = signer.new_node(node_config);

	let manager = LoopbackSignerKeysInterface { node_id, signer: Arc::new(signer) };
	Box::new(Adapter { inner: manager })
}
