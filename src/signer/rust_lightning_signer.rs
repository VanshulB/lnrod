use lightning::chain::keysinterface::{SpendableOutputDescriptor, KeysManager, KeysInterface, DelayedPaymentOutputDescriptor, StaticPaymentOutputDescriptor};
use crate::signer::keys::{SpendableKeysInterface, DynSigner, InnerSign, PaymentSign};
use bitcoin::secp256k1::{All, Secp256k1, SecretKey, PublicKey};
use bitcoin::{Script, TxOut, Transaction};
use anyhow::Result;
use lightning_signer::util::loopback::{LoopbackSignerKeysInterface, LoopbackChannelSigner};
use std::time::Duration;
use lightning_signer::server::my_signer::MySigner;
use lightning_signer::node::node::NodeConfig;
use lightning_signer::server::my_keys_manager::KeyDerivationStyle;
use std::sync::Arc;
use lightning::ln::msgs::DecodeError;
use std::any::Any;

struct Adapter {
	inner: LoopbackSignerKeysInterface
}

impl PaymentSign for LoopbackChannelSigner {
	#[allow(unused)]
	fn sign_counterparty_payment_input_t(&self, spend_tx: &Transaction, input_idx: usize, descriptor: &StaticPaymentOutputDescriptor, secp_ctx: &Secp256k1<All>) -> Result<Vec<Vec<u8>>, ()> {
		todo!()
	}

	#[allow(unused)]
	fn sign_dynamic_p2wsh_input_t(&self, spend_tx: &Transaction, input_idx: usize, descriptor: &DelayedPaymentOutputDescriptor, secp_ctx: &Secp256k1<All>) -> Result<Vec<Vec<u8>>, ()> {
		todo!()
	}
}

impl InnerSign for LoopbackChannelSigner {
	fn box_clone(&self) -> Box<dyn InnerSign> {
		Box::new(self.clone())
	}

	fn as_any(&self) -> &dyn Any {
		self
	}

	fn vwrite(&self, _writer: &mut Vec<u8>) -> Result<(), std::io::Error> {
		//self.write(writer)
		// Do nothing for now, we'll have our own persistence strategy
		Ok(())
	}
}

impl KeysInterface for Adapter {
	type Signer = DynSigner;

	fn get_node_secret(&self) -> SecretKey {
		self.inner.get_node_secret()
	}

	fn get_destination_script(&self) -> Script {
		self.inner.get_destination_script()
	}

	fn get_shutdown_pubkey(&self) -> PublicKey {
		self.inner.get_shutdown_pubkey()
	}

	fn get_channel_signer(&self, inbound: bool, channel_value_satoshis: u64) -> Self::Signer {
		let inner = self.inner.get_channel_signer(inbound, channel_value_satoshis);
		DynSigner {
			inner: Box::new(inner)
		}
	}

	fn get_secure_random_bytes(&self) -> [u8; 32] {
		self.inner.get_secure_random_bytes()
	}

	fn read_chan_signer(&self, _reader: &[u8]) -> Result<Self::Signer, DecodeError> {
		unimplemented!()
	}
}

impl SpendableKeysInterface for Adapter {
	/// Creates a Transaction which spends the given descriptors to the given outputs, plus an
	/// output to the given change destination (if sufficient change value remains). The
	/// transaction will have a feerate, at least, of the given value.
	///
	/// Returns `Err(())` if the output value is greater than the input value minus required fee or
	/// if a descriptor was duplicated.
	///
	/// We do not enforce that outputs meet the dust limit or that any output scripts are standard.
	///
	/// May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
	/// this KeysManager or one of the `DynSigner` created by this KeysManager.
	fn spend_spendable_outputs(
		&self, descriptors: &[&SpendableOutputDescriptor], outputs: Vec<TxOut>,
		change_destination_script: Script, feerate_sat_per_1000_weight: u32,
		secp_ctx: &Secp256k1<All>,
	) -> Result<Transaction> {
		self.inner.backing.spend_spendable_outputs(descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight, secp_ctx)
			.map_err(|()| anyhow::anyhow!("failed in spend_spendable_outputs"))
	}
}

pub(crate) fn make_signer(seed: &[u8; 32], cur: Duration) -> Box<dyn SpendableKeysInterface<Signer=DynSigner>> {
	let signer = MySigner::new();
	let node_config = NodeConfig {
		key_derivation_style: KeyDerivationStyle::Native
	};
	let node_id = signer.new_node(node_config);

	let backing =
		KeysManager::new(&seed, cur.as_secs(), cur.subsec_nanos());
	let manager = LoopbackSignerKeysInterface {
		node_id,
		signer: Arc::new(signer),
		backing
	};
	Box::new(Adapter { inner: manager })
}
