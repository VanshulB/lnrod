use crate::signer::keys::{DynSigner, InnerSign, PaymentSign, SpendableKeysInterface};
use anyhow::Result;
use bitcoin::secp256k1::recovery::RecoverableSignature;
use bitcoin::secp256k1::{All, PublicKey, Secp256k1, SecretKey};
use bitcoin::{Address, Network, Script, Transaction, TxOut};
use lightning::chain::keysinterface::{
	DelayedPaymentOutputDescriptor, KeysInterface, SpendableOutputDescriptor,
	StaticPaymentOutputDescriptor,
};
use lightning::ln::msgs::DecodeError;
use lightning_signer::lightning;
use lightning_signer::node::NodeConfig;
use lightning_signer::signer::multi_signer::MultiSigner;
use lightning_signer::signer::my_keys_manager::KeyDerivationStyle;
use lightning_signer::util::loopback::{LoopbackChannelSigner, LoopbackSignerKeysInterface};
use std::any::Any;
use std::fs;
use std::str::FromStr;
use std::sync::Arc;
use lightning_signer_server::persist::persist_json::KVJsonPersister;
use log::info;
use crate::hex_utils;
use crate::lightning::ln::script::ShutdownScript;

struct Adapter {
	inner: LoopbackSignerKeysInterface,
}

impl PaymentSign for LoopbackChannelSigner {
	#[allow(unused)]
	fn sign_counterparty_payment_input_t(
		&self, spend_tx: &Transaction, input_idx: usize,
		descriptor: &StaticPaymentOutputDescriptor, secp_ctx: &Secp256k1<All>,
	) -> Result<Vec<Vec<u8>>, ()> {
		todo!()
	}

	#[allow(unused)]
	fn sign_dynamic_p2wsh_input_t(
		&self, spend_tx: &Transaction, input_idx: usize,
		descriptor: &DelayedPaymentOutputDescriptor, secp_ctx: &Secp256k1<All>,
	) -> Result<Vec<Vec<u8>>, ()> {
		todo!()
	}
}

impl InnerSign for LoopbackChannelSigner {
	fn box_clone(&self) -> Box<dyn InnerSign> {
		Box::new(self.clone())
	}

	fn as_any(&self) -> &dyn Any {
		self
	}

	fn vwrite(&self, _writer: &mut Vec<u8>) -> Result<(), std::io::Error> {
		//self.write(writer)
		// Do nothing for now, we'll have our own persistence strategy
		Ok(())
	}
}

impl KeysInterface for Adapter {
	type Signer = DynSigner;

	fn get_node_secret(&self) -> SecretKey {
		self.inner.get_node_secret()
	}

	fn get_destination_script(&self) -> Script {
		self.inner.get_destination_script()
	}

	fn get_shutdown_scriptpubkey(&self) -> ShutdownScript {
		self.inner.get_shutdown_scriptpubkey()
	}

	fn get_channel_signer(&self, inbound: bool, channel_value_satoshis: u64) -> Self::Signer {
		let inner = self.inner.get_channel_signer(inbound, channel_value_satoshis);
		DynSigner { inner: Box::new(inner) }
	}

	fn get_secure_random_bytes(&self) -> [u8; 32] {
		self.inner.get_secure_random_bytes()
	}

	fn read_chan_signer(&self, _reader: &[u8]) -> Result<Self::Signer, DecodeError> {
		unimplemented!()
	}

	fn sign_invoice(&self, _invoice_preimage: Vec<u8>) -> Result<RecoverableSignature, ()> {
		unimplemented!()
	}
}

impl SpendableKeysInterface for Adapter {
	/// Creates a Transaction which spends the given descriptors to the given outputs, plus an
	/// output to the given change destination (if sufficient change value remains). The
	/// transaction will have a feerate, at least, of the given value.
	///
	/// Returns `Err(())` if the output value is greater than the input value minus required fee or
	/// if a descriptor was duplicated.
	///
	/// We do not enforce that outputs meet the dust limit or that any output scripts are standard.
	///
	/// May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
	/// this KeysManager or one of the `DynSigner` created by this KeysManager.
	fn spend_spendable_outputs(
		&self, descriptors: &[&SpendableOutputDescriptor], outputs: Vec<TxOut>,
		change_destination_script: Script, feerate_sat_per_1000_weight: u32,
		secp_ctx: &Secp256k1<All>,
	) -> Result<Transaction> {
		self.inner
			.spend_spendable_outputs(
				descriptors,
				outputs,
				change_destination_script,
				feerate_sat_per_1000_weight,
				secp_ctx,
			)
			.map_err(|()| anyhow::anyhow!("failed in spend_spendable_outputs"))
	}
}

pub(crate) fn make_signer(network: Network, ldk_data_dir: String) -> Box<dyn SpendableKeysInterface<Signer = DynSigner>> {
	let node_id_path = format!("{}/node_id", ldk_data_dir);
	let signer_path = format!("{}/signer", ldk_data_dir);
	let persister = Arc::new(KVJsonPersister::new(&signer_path));
	// FIXME use Node directly - requires rework of LoopbackSignerKeysInterface in the rls crate
	let signer = MultiSigner::new_with_persister(persister, false, vec![]);
	if let Ok(node_id_hex) = fs::read_to_string(node_id_path.clone()) {
		let node_id = PublicKey::from_str(&node_id_hex).unwrap();
		assert!(signer.get_node(&node_id).is_ok());

		let manager = LoopbackSignerKeysInterface { node_id, signer: Arc::new(signer) };
		Box::new(Adapter { inner: manager })
	} else {
		let node_config = NodeConfig {
			network,
			key_derivation_style: KeyDerivationStyle::Native
		};
		let node_id = signer.new_node(node_config);
		fs::write(node_id_path, node_id.to_string()).expect("write node_id");
		let node = signer.get_node(&node_id).unwrap();

		let manager = LoopbackSignerKeysInterface { node_id, signer: Arc::new(signer) };

		let shutdown_scriptpubkey = manager.get_shutdown_scriptpubkey().into();
		let shutdown_address = Address::from_script(&shutdown_scriptpubkey, network)
			.expect("shutdown script must be convertible to address");
		info!("adding shutdown address {} to allowlist for {}", shutdown_address, hex_utils::hex_str(&node_id.serialize()));
		node.add_allowlist(&vec![shutdown_address.to_string()]).expect("add to allowlist");

		Box::new(Adapter { inner: manager })
	}
}
